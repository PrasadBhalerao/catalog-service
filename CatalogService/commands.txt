# Login to Azure
az login
# Create an Azure resource group
az group create --name Mcart-RG --location centralindia

# Create a one node cluster 
az aks create --resource-group Mcart-RG --name MCart-AKS-Cluster --node-count 1 --generate-ssh-keys --node-vm-size=Standard_B4ms

# Create acr
az acr create -n mcartacr1 -g Mcart-RG --sku Basic
 
Mcart-RG
Mcart-AKS-Cluster
MCartACR 
mcartsa

az ad sp create-for-rbac --name "AzureDevOpsSP" --role contributor --scopes /subscriptions/<subscription-id>/resourceGroups/<resource-group-name>
az ad sp create-for-rbac --name "AzureDevOpsSP" --role contributor --scopes /subscriptions/8209aacc-e6ac-4604-bbd8-dfdcf7a679ae/resourceGroups/Mcart-RG

Azure subscription 1

az ad app federated-credential create --id <application-object-id> \ --parameters '{"name":"GitHubActionsFederatedCredential","issuer":"https://token.actions.githubusercontent.com","subject":"repo:<your-github-org>/<your-github-repo>:ref:refs/heads/<your-branch>","audiences":["api://AzureADTokenExchange"],"description":"Federated credential from GitHub Actions"}'

Replace <application-object-id> with the service principal's object ID.
Replace <your-github-org>, <your-github-repo>, and <your-branch> with your GitHub organization, repository, and branch

az ad app federated-credential create --id 82b05c23-f536-4eee-bdcb-24c53681f9a1 --parameters '{"name":"GitHubActionsFederatedCredential","issuer":"https://token.actions.githubusercontent.com","subject":"repo:PrasadBhalerao/catalog-service:ref:refs/heads/main","audiences":["api://AzureADTokenExchange"],"description":"Federated credential from GitHub Actions"}'

az identity federated-credential create --name GitHubActionCred --identity-name "AzureDevOpsSP" --resource-group "Mcart-RG" --issuer "https://token.actions.githubusercontent.com" --subject "repo:PrasadBhalerao/catalog-service:ref:refs/heads/main"

az role assignment create --assignee "82b05c23-f536-4eee-bdcb-24c53681f9a1" --role "Contributor" --scope "/subscriptions/8209aacc-e6ac-4604-bbd8-dfdcf7a679ae"

az role assignment create --assignee "82b05c23-f536-4eee-bdcb-24c53681f9a1" --role Contributor --scope /subscriptions/8209aacc-e6ac-4604-bbd8-dfdcf7a679ae/resourceGroups/Mcart-RG/providers/Microsoft.ContainerRegistry/registries/mcartacr1

az aks get-credentials --resource-group <RESOURCE_GROUP> --name <AKS_CLUSTER_NAME>


az aks stop --resource-group Mcart-RG --name Mcart-AKS-Cluster
az aks start --resource-group Mcart-RG --name Mcart-AKS-Cluster

az role assignment create --assignee "82b05c23-f536-4eee-bdcb-24c53681f9a1" --role "Storage Blob Data Contributor" --scope /subscriptions/8209aacc-e6ac-4604-bbd8-dfdcf7a679ae/resourceGroups/MC_Mcart-RG_MCart-AKS-Cluster_centralindia/providers/Microsoft.Storage/storageAccounts/mcartsa

az role assignment list --assignee "82b05c23-f536-4eee-bdcb-24c53681f9a1"

# Get credentials for the cluster
az aks get-credentials --resource-group Mcart-RG --name MCart-AKS-Cluster



# Create a new service account named my-service-account
 kubectl create serviceaccount "mcart-sa"

 kubectl get serviceAccounts "mcart-sa" -n default -o=jsonpath={.secrets[*].name}
 kubectl get serviceAccounts <service-account-name> -n <namespace> -o=jsonpath={.secrets[*].name}
 kubectl get secret "mcart-sa" -n default -o json

# List nodes
kubectl get nodes
 
# Create the load balancing service
kubectl apply -f sqlloadbalancer.yaml 
 
# Create external storage with PV and PVC
kubectl apply -f sqlstorage.yaml 
kubectl apply -f pvc.yaml 
 
 
# Display the persistent volume and claim
kubectl get pv
kubectl get pvc
 
# Optional: In case if you want to explore differennt choices of storage classes you can run this line  otherwise you can ignore it
kubectl get storageclass
 
# Use Kubernetes secrets to store required sa password for SQL Server container. This is a best Practice
# If you want to delete the previously created secret use this one otherwise avoid it and go to next line
kubectl delete secret mssql-secret 
 
# use complex password
kubectl create secret generic mssql-secret --from-literal=SA_PASSWORD="Prasad@123"
 
# Deploy the SQL Server 2019 container
kubectl apply -f sqldeployment.yaml 
 
# List the running pods and services
kubectl get pods
kubectl get services
 
# TO fetch details about the POD
kubectl describe pod mssql

# Connect to the SQL Server pod with Azure Data Studio
# Retrieve external IP address
ip=$(kubectl get services | grep mssql | cut -c45-60)
echo $ip
  
# Simulate a failure by killing the pod. Delete pod exactkly does it.
kubectl delete pod ${podname}
 
# Wait one second
echo Waiting 3 second to show newly started pod
sleep 3
 
# now retrieve the running POD and you see the that POD name is different because Kubernetes recreated 
#it after we deleted the earlier one
echo Retrieving running pods
kubectl get pods
 
# Get all of the running components
kubectl get all
 
# for Troubelshooting purpose you can use this command to view the events  
 
kubectl describe pod -l app=mssql
 
 
 
# Display the container logs
kubectl logs -l app=aksdemo


# 
docker build -t prasadbhalerao/demo .
docker run -d -p 3000:3000 --name node-app prasadbhalerao/demo

docker logs --since=1h 'container_id'

#kubectl create secret docker-registry pb-docker-creds --docker-server= --docker-username= --docker-password=

docker tag prasadbhalerao/demo pbaksdemo.azurecr.io/prasadbhalerao/demo:latest

docker login pbaksdemo.azurecr.io

docker push pbaksdemo.azurecr.io/prasadbhalerao/demo:latest

##kubectl secret

kubectl apply -f appdeployment.yaml 

kubectl replace -f appdeployment.yaml

kubectl apply -f service.yaml

kubectl apply -f configmap.yaml

kubectl apply -f sqlloadbalancer.yaml

kubectl get deployment

kubectl delete deployment aksdemo-deployment -n default
kubectl delete deployment mssql-deployment -n default

kubectl delete service app-service -n default
kubectl delete service mssql-service -n default

kubectl get services
kubectl get pods

kubectl logs <pod_name>